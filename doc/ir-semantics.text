# The formal language

P ::= Function main ()  ↦ F, (Df ↦ F)*   program:            main function and other functions
F ::= (lᵥ ↦ V)*                          function body:      can contain multiple versions
V ::= start ↦ i, I                       a function version: instruction stream with dedicated start
I ::= (l ↦ i)*                           instruction stream: labeled instructions

Df ::= Function f (formal*)              function declaration (signature)

x        variables

f  function name
l  branch label
lᵥ version label

Reserved Names:
main      main function    (execution of program starts here)
start     start label      (execution of function starts here)

formal ::=      formal argument
| const x
| mut x

a  addresses

i ::=    instructions
| const x = e                   constant variable
| call x = e (arg*)             function call
| mut x = e                     mutable variable
| x <- e                        assignment
| x.n <- e                      tuple update
| branch e l₁ l₂                conditional
| goto l                        goto
| print e                       print
| return e                      return
| osr(e, f, lᵥ, l, osr-map*)    osr : (can be used for osr-in and osr-out)

n - tuple index name

arg ::=
| e
| &x

e ::=     expression
| se                    simple expression
| primop(se*)           primitive operation (pure)
| <n:se*>               tuple ctr
| se.n                  tuple access

se ::=    simple expressions
| lit                   literals
| x                     variables
| 'f                    create function reference

lit ::=  literals
| nil
| true | false
| 0 | 1 | 2 | ...
| "strings"

v :=     values
| lit                   literals
| f                     function reference
| <n:v*>                tuples

(Note: heap adresses are not values)

osr-map ::=    osr mapping declaration
| const x = e
| mut x
| mut x = x

# Natural operational semantics

E ::= (x ↦ val v | x ↦ ref a | x ↦ ⊥)*  lexical environment
H ::= (l ↦ v)                           mutable heap

T ::= (lit)*                    output trace

## Configuration

  C ::= (x, E, I, l)                 continuation:  accumulator, environment, instructions, label

  M ::= (P, C*) : (I, T, H, E, l)    machine state: program, continuations : instructions, trace, heap, environment, pc

## Auxiliary functions

succ I l =
 | goto l'                                -> [l']
 | branch _ l' l''                        -> [l', l'']
 | when I = {..., l -> _, l' -> _, ...}   -> [l']
 | _                                      -> []

pred I l =
  { l' ∈ I : succ I l' = l }

Lookup (partial) function, returns a v:
  (H,E)[x] :=
    v    if E ∋ (x ↦ val v)
    H(a) if E ∋ (x ↦ ref a)

Update (partial) function, returns an H:
  (H,E)[x ← v] :=
    H[a ↦ v] if E ∋ (x ↦ ref a)

## Evaluation of (simple) expressions:

  simple-eval P H E x   = (H,E)[x]
  simple-eval P H E lit = lit
  simple-eval P H E 'f  = f
    where Df ∈ dom P
      and Df  = Function f (formal*)

  eval P H E se          = simple-eval P H E se
  eval P H E primop(se*) = 〚primop〛(v*)
    where v := simple-eval P H E se
  eval P H E <n:se*>      = <n:v*>
    where v := simple-eval P H E se
  eval P H E se.n          = vₙ
    where v := simple-eval P H E se
      and v = <...,n:vₙ, ...>

## Osr transformation of environment

  osr-env P H E (const x = e) = (x ↦ eval P H E e)
  osr-env P H E (mut x)       = (x ↦ ⊥)
  osr-env P H E (mut x = y)   = (x ↦ a)
    where a = E(y)

## Argument evaluation

  eval-arg P H E const  e =  val eval P H E e
  eval-arg P H E mut   &x =  ref a
    where E ∋ (x ↦ ref a)

## Reduction relation '-->'

  (P, C*) : (I, T, H, E, l) --> (P, C*) : step I(l) (P, I, T, H, E, l)

  (P, C*) : (I, T, H, E, l) --> (P, (C*, C')) : (I', T, H, E', start)
    when I(l) = (call x = e (arg*))
     and f  := eval P H E e
     and Df ∈ dom P
     and Df  = Function f ((mod y)*)
     and I' := hd P(Df)
     and E' := (y ↦ eval-arg P H E mod arg)*
     and C' := (x, E, I, succ I l)

  (P, (C*, C')) : (I, T, H, E, l) --> (P, C*) : (I', T, H, E'', l')
    when I(l) = (return e)
     and v   := eval P H E e
     and C'   = (x', E', I', l')
     and E'' := E'[x' ↦ v]

## One step reduction

  step   (const x = e) (P, I, T, H, E, l)
       = (I, T, H, E[x ↦ v], succ I l)
    when v := eval P H E e

  step   (mut x = e) (P, I, T, H, E, l)
       = (I, T, H[a ↦ v], E[x ↦ a], succ I l)
    when v := eval P H E e
     and a - fresh

  step   (x ← e) (P, I, T, H, E, l)
       = (I, T, (H,E)[x ← v], E, succ I l)
    when v := eval P H E e

  step   (x.n ← e) (P, I, T, H, E, l)
       = (I, T, (H,E)[x ← v'], E, succ I l)
    when vₐ := eval P H E e
     and v   = (H,E)[x]
     and v   = <..., n:vₙ, ...>
     and v'  = <..., n:vₐ, ...>

  step   (print e) (P, I, T, H, E, l)
       = (I, (T, v), H, E, succ I l)
    when v := eval P H E e

  step   (branch e l₁ l₂) (P, I, T, H, E, l)
       = (I, T, H, E, l')
    when v  := eval P H E e
     and l' := if v = true  then l₁
               if v = false then l₂

  step   osr(e, f^, lᵥ^, l^, (osr-map*)) (P, I, T, H, E, l)
       = (I', T, H, E', l')
    when v := eval P H E e
     and if v = false then
         I' := I
         l' := l
         E' := E
     and if v = true then
         Df ∈ dom P
         Df  = Function f^ (formal*)
         I' := P(Df, lᵥ^)
         l' := l^
         E' := (osr-env P H E osr-map)*

# Scopes

declares i =
  | mut x _         -> [x]
  | const x _       -> [x]
  | _               -> []

requires i =
  | mut x = e
  | const x = e
  | osr (e, f, lᵥ, l, (x = ee)*)
                    -> vars(e) ∪ vars(ee)*
  | x <- e          -> x :: vars(e)
  | branch x _
  | print x         -> [x]
  | _               -> []

scope S ::= x*
scope assignment A ::= ((v, l) → S)*

## Declarative scoping judgment

This judgment just classifies "possible" scope assignments A for
a program P. It does not characterize the tightest possible
assignment¹, as it allows to implicitly drop variables from scope on
each transition (the ⊇ relations in the (v, l → i) rule). In
particular, it cannot forbid shadowing, as it is always possible to
drop all same-named bindings before a declaration.

¹: the tightest possible assignment can be defined impredicatively as
the pointwise intersection of all valid judgments, which is
well-defined given that valid scopes are bounded by the set of
variables defined in the program.

  ∀(v → M) ∈ P:   A, P ⊨d v → M
  ----------------------------
            A, P ⊨d

  ∀(l → i) ∈ M:   A, P ⊨d v, l → i
  -------------------------------
         A, P ⊨d v → M

  requires i ⊆ A(v,l)
  ∀l' ∈ succ(P(v),l),  A(v,l) ∪ declares i ⊇ A(v,l')
  A, P ⊨d i : A(v,l)
  pred(P(v), l) = ∅  ⇒  i = start
  -----------------------------------------------------------
  A, P ⊨d v, l → i

The judgment (A, P ⊨d i : S) below is the instruction-specific judgment
that checks the scope restrictions that are specific to each
instruction, rather than the general control-flow constraints and the
generic requires/declares handling.

  -----------------
  A, P ⊨d start : ∅

              A(v', l') = x*
  -------------------------------------
  A, P ⊨d osr(e, f, lᵥ', l', (x = ee*)) : S

  ---------------
  A, P ⊨d stop : ∅

  i ∉ {start, osr, stop}
  ----------------------
  A, P ⊨d i : S

## Algorithmic scoping judgment

(A, P ⊨a), (A, P ⊨a v → M), (A, P ⊨a i : S): as in the declarative
scoping judgment. Only (A, P ⊨a v, l → i) differs.

  S := A(v,l) \ declares i
  (⋂_{l* ∈ pred(P(v),l)} A(v,l*)) = S ∪ requires i
  A, P ⊨a i : S
  ------------------------------------------------
  A, P ⊨a v, l → i

There is a fundamental difference in the role of the scope assignment
A between the declarative and algorithmic judgments.

In the declarative judgment, A(v,l) points to the variables
*available* in the *ingoing* scope of the instruction at location
(v,l): the scope that is available when arriving to the instruction
from a predecessor. The variables that are available in the outgoing
scope can be computed from this value as (A(v,l) ∪ declares i).

In the algorithmic judgment, A(v,l) points to the variables that are
*required* in the *outgoing* scope of the instruction at location
(v,l): the scope that is required when leaving the instruction to
a successor. The variables required in the ingoing scope can be
computed from this value as (A(v,l) \ declares i).

In the declarative judgment, the relation between an instruction scope
and its neighbors is under-specified: a predecessor's outgoing scope
may have more variables than our ingoing scope, and any successor's
ingoing scope may have less variable than our outgoing scope.

In the algorithmic judgment, the relation between the scopes of an
instruction and its neighbors is deterministic: an instruction's
ingoing scope is exactly the variables that are common among all its
predecessors. Implicitly dropping a variable that will never be used
again is possible: this is done by choosing a A(v,l) that is smaller
than the instruction's ingoing set plus (declares i).

Problem: I think there is a problem with the notion of outgoing scope
as it is currently defined for multi-successor instructions, as it
forces all successors to see the same set of required
variables. I think that introducing `drop` instructions would be the
cleanest way to work around these issues – by removing any
underspecification from the declarative specification.
