# The formal language

  P ::= Function main ()  ↦ F, (Df ↦ F)*   program:            main function and other functions
  F ::= (lᵥ ↦ V)*                          function body:      can contain multiple versions
  V ::= start ↦ i, I                       a function version: instruction stream with dedicated start
  I ::= (l ↦ i)*                           instruction stream: labeled instructions

Df ::= Function f (formal*)              function declaration (signature)

  x        variables

  f  function name
  l  branch label
  lᵥ version label

Reserved Names:
  main      main function    (execution of program starts here)
  start     start label      (execution of function starts here)

  formal ::=      formal argument
  | t x₀

  a  addresses

  i ::=    instructions
  | ref xⁿ = ref e                ssa variable
  | val xⁿ = e | e (arg*)         ssa variable
  | t xⁿ = φ(xⁱ*)                 phi node
  | drop xⁿ                       drop a variable from scope
  | clear xⁿ                      de-initialization of a mutable
  | xⁿ <- e                       assignment
  | xⁿ[e] <- e                    array assignment
  | branch e l₁ l₂                conditional
  | goto l                        goto
  | print e                       print
  | return e                      return
  | osr(e, f, lᵥ, l, osr-map*)    osr : (can be used for osr-in and osr-out)

  t ::=    storage
  | val
  | ref

Storage modifier annotations are checked at compile time and erased at runtime

  arg ::= e | &xⁱ

A function argument is either an arbitrary expression `x` or `&x`,
which references a mutable variable `x`; the function declaration is
expecting a mutable variable `mut y` in this position, and `y` is
aliased to `x` from the caller environment; in particular, any
mutation of `y` within the function body will be visible on `x` after
the function has returned.

  e ::=     expression
  | se                    simple expression
  | primop(se*)           primitive operation (pure)
  | array(se)             empty array constructor
  | [se*]                 array constructor
  | xⁿ[se]                array index
  | length(xⁿ)            array length

  se ::=    simple expressions
  | lit                   literals
  | xⁿ                    variables
  | 'f                    create function reference

  lit ::=  literals
  | nil
  | true | false
  | 0 | 1 | 2 | ...

  v :=     values
  | lit                   literals
  | f                     function reference
  | [v*]                  array

Note: heap adresses are not values. They cannot be explicitly
mentioned, but &x can be used to alias the mutable variable x in an
osr or function call.

  osr-map ::=    osr mapping declaration
  | ref x = ref e
  | ref x = &xⁱ
  | ref x = ⊥
  | val x = e

# Natural operational semantics

  E ::= (x ↦ val v | x ↦ ref a)*  lexical environment
  H ::= (a ↦ v | a ↦ ⊥)                   mutable heap

  T ::= (lit)*                    output trace

## Configuration

  C ::= (x, E, I, l)                 continuation:  accumulator, environment, instructions, label

  M ::= (P, C*) : (I, T, H, E, l)    machine state: program, continuations : instructions, trace, heap, environment, pc

## Auxiliary functions

  succ I l =
   | goto l'                                -> [l']
   | branch _ l' l''                        -> [l', l'']
   | when I = {..., l -> _, l' -> _, ...}   -> [l']
   | _                                      -> []

  pred I l =
    { l' ∈ I : succ I l' = l }

Lookup (partial) function, returns a v:

  (H,E)[x] :=
    v    if E ∋ (x ↦ val v)
    H(a) if E ∋ (x ↦ ref a)

Update (partial) function, returns an H:

  (H,E)[x ← v] :=
    H[a ↦ v] if E ∋ (x ↦ ref a)

## Evaluation of (simple) expressions:

  simple-eval P H E xⁱ  = (H,E)[x]
  simple-eval P H E lit = lit
  simple-eval P H E 'f  = f
    where Df ∈ dom P
      and Df  = Function f (formal*)

  eval P H E se          = simple-eval P H E se
  eval P H E primop(se*) = 〚primop〛(v*)
    where (v := simple-eval P H E se)*
  eval P H E [se*]       = [v*]
    where (v := simple-eval P H E se)*
  eval P H E x[se]       = vₙ
    where v := (H,E)[x]
      and n := simple-eval P H E se
      and v  = [v₁..., vₙ, ...]
  eval P H E array(se)   = [nil⁽ⁿ⁾]
    where n := simple-eval P H E se
  eval P H E length(xⁱ)  = n
    where v := (H,E)[x]
      and v  = [v₁..., vₙ]

## One step reduction

  step   (xⁱ = e) (P, I, T, H, E, l)
       = (I, T, H, E[x ↦ val v], succ I l)
    when v := eval P H E e

  step   (xⁱ = ref e) (P, I, T, H, E, l)
       = (I, T, H[a ↦ v], E[x ↦ ref a], succ I l)
    when v := eval P H E e
     and a - fresh

  step   (xⁱ = φ(...)) (P, I, T, H, E, l)
       = (I, T, H, E, succ I l)  # nop

  step   (xⁱ ← e) (P, I, T, H, E, l)
       = (I, T, (H,E)[x ← v], E, succ I l)
    when v := eval P H E e

  step   (clear xⁱ) (P, I, T, H, E, l)
       = (I, T, (H,E)[x ← ⊥], E, succ I l)

  step   (drop xⁱ) (P, I, T, H, E, l)
       = (I, T, H, E', succ I l)
    when E' := E \ {x}

  step   (xⁱ[eᵢ] ← eₐ) (P, I, T, H, E, l)
       = (I, T, (H,E)[x ← v'], E, succ I l)
    when n  := eval P H E eᵢ
     and vₐ := eval P H E eₐ
     and v  := (H,E)[x]
     and v   = [v₁..., vₙ, ...]
     and v' := [v₁..., vₐ, ...]

  step   (print e) (P, I, T, H, E, l)
       = (I, (T, v), H, E, succ I l)
    when v := eval P H E e

  step   (branch e l₁ l₂) (P, I, T, H, E, l)
       = (I, T, H, E, l')
    when v  := eval P H E e
     and l' := if v = true  then l₁
               if v = false then l₂

  step   osr(e, f^, lᵥ^, l^, (osr-map*)) (P, I, T, H, E, l)
       = (I', T, H+(H'*), E'*, l')
    when v := eval P H E e
     and if v = false then
         I' := I
         l' := l
         H' := H
         E' := E
     and if v = true then
         Df ∈ dom P
         Df  = Function f^ (formal*)
         I' := P(Df, lᵥ^)
         l' := l^
         (E', H')* := eval-osr-map osr-map

  eval-osr-map P H E (y = &z)    = (y ↦ ref a, ∅)
    when E ∋ (z ↦ ref a)
  eval-osr-map P H E (y = ref e) = (y ↦ ref a, a ↦ v)
    when v := eval P H E e
     and a - fresh
  eval-osr-map P H E (y = ⊥)     = (y ↦ ref a, a ↦ ⊥)
    when a - fresh
  eval-osr-map P H E (y = e)     = (y ↦ val v, ∅)
    when v := eval P H E e

## Reduction relation '-->'

  (P, C*) : (I, T, H, E, l) --> (P, C*) : step I(l) (P, I, T, H, E, l)

  (P, C*) : (I, T, H, E, l) --> (P, (C*, C')) : (I', T, H', E', start)
    when I(l) = (var xⁿ = e (arg*))
     and f  := eval P H E e
     and Df ∈ dom P
     and Df  = Function f ((t y)*)
     and I' := hd P(Df)
     and E' := (eval-call-arg P H E (t y) arg)*
     and C' := (x, E, I, succ I l)

  (P, (C*, C')) : (I, T, H, E, l) --> (P, C*) : (I', T, H, E'', l')
    when I(l) = (return e)
     and v   := eval P H E e
     and C'   = (x', E', I', l')
     and E'' := E'[x' ↦ var v]

  eval-call-arg P H E (ref y) &z  = (y ↦ ref a)
    when E ∋ (z ↦ ref a)
  eval-call-arg P H E (val y) e   = (y ↦ val v)
    when v := eval P H E e

# Scopes

declares i =
  | t xⁿ = _         -> [xⁿ ↦ t]

requires i =
  | t xⁿ = e
  | t xⁿ = ref e       ->
      vars(e)
  | t xⁿ = e (arg*)    ->
      vars(e) ∪ ⋃vars(arg)*
  | t xⁿ = φ(xⁱ*)      ->
      ∅
  | xⁿ[e₁] <- e₂       ->
      xⁿ :: vars(e₁) ∪ vars(e₂)
  | xⁿ <- e            ->
      xⁿ :: vars(e)
  | print e
  | return e
  | clear x
  | drop x             ->
      [x*]  // TODO Better notation, requires some xⁿ in scope
  | branch e l₁ l₂     ->
      vars(e)
  | osr(e, f, lᵥ, l, osr-map*) ->
      vars(e) ∪ ⋃vars(osr-map)*

requires_typed i =
  | t xⁿ = e (arg*) ->
      ∀ &xⁱ ∈ arg*, (xⁱ ↦ ref)
  | osr(e, f, lᵥ, l, osr-map*) ->
      ∀ &xⁱ ∈ osr-map*, (xⁱ ↦ ref)
  | t xⁿ = φ(xⁱ*) ->
      (xⁱ ↦ t)*
  | xⁿ[e₁] <- e₂
  | xⁿ <- e            ->
      (xⁿ ↦ ref)
  | clear xⁱ
  | drop xⁱ            ->
      (xⁱ ↦ ref)

removes i =
  | drop x        -> x*   // TODO Better notation, removes all xⁿ in scope
  | t xⁿ = φ(xⁱ*) -> xⁱ*


scope S ::= (x → t)*
scope assignment (in scopes and out scopes
  Ai ::= ((v, l) → S)*
  Ao ::= ((v, l) → S)*

## Scoping judgment

TODO: Fix for functions

This judgment just classifies a valid scope assignment A for a program P.
Every instruction has an in and out scope. The out scope is local to the
instruction, the in scope is the pointwise merge of all in scopes of the
predecessors.

  ∀(v → V) ∈ P:   Ai, Ao, P ⊨d v → V
  ----------------------------------
            Ai, Ao, P ⊨d

  ∀(l → i) ∈ V:   Ai, Ao, P ⊨d v, l → i
  --------------------------------------
         Ai, Ao, P ⊨d v → V


  Ai(v,l) = ⋃ merge { Ao(v,l') : l' ∈ pred(P(v),l) }
  requires i ⊆ dom(Ai(v,l))
  requires_typed i ⊆ Ai(v,l)
  Ao(v,l) = Ai(v,l) ∪ declares i \ removes i
  A, P ⊨d i : Ai(v,l)
  pred(P(v), l) = ∅  ⇒  i = start
  -----------------------------------------------------------
  A, P ⊨d v, l → i

If an instruction has multiple predecessors all imported variables must
be in correct SSA form. That means every branch exports exactly one
SSA variable. The merged scope will contain both variables xⁱ and xⁿ.
Therefore a phi must occur before the next merge.

  xⁱ ∈ S₁  ⇒  xⁿ ∈ S₂
  xⁱ - unique x in S₁
  xⁿ - unique x in S₂
  S := S₁ ∪ S₂
  --------------------------------
  merge S₁ S₂ : S

The judgment (A, P ⊨d i : S) below is the instruction-specific judgment
that checks the scope restrictions that are specific to each
instruction, rather than the general control-flow constraints and the
generic requires/declares handling.

  -----------------
  A, P ⊨d start : ∅


  A(v', l') = x*
  -------------------------------------
  A, P ⊨d osr(e, f, lᵥ', l', osr-map*) : S


  ---------------
  A, P ⊨d stop : ∅

  i ∉ {start, osr, stop}
  ----------------------
  A, P ⊨d i : S

This strict scoping judgment is deterministic on reachable program
points: A is uniquely determined by P on those: start instructions
have to be in the empty scope, and then the scope of successors
instructions are uniquely determined. (This is thanks to `drop` that
lets us use equality instead of a superset relation there.)
