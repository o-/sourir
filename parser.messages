program: BRANCH NIL IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 110.
##
## instruction -> BRANCH expression label . label [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## BRANCH expression label 
##

Parsing an instruction, we parsed "branch <expr> <label>" so far;
a label, for example "foo", is now expected to construct a branch
instruction
"branch <expr> <label> <label>".

program: BRANCH NIL TRIPLE_DOT 
##
## Ends in an error in state: 109.
##
## instruction -> BRANCH expression . label label [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## BRANCH expression 
##

Parsing an instruction, we parsed "branch <expr>" so far; a label, for
example "foo", is now expected to construct a branch instruction
"branch <expr> <label> <label>".

program: BRANCH TRIPLE_DOT 
##
## Ends in an error in state: 108.
##
## instruction -> BRANCH . expression label label [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## BRANCH 
##

Parsing an instruction, we parsed "branch" so far; an expression, for
example "(x == 2)", is now expected to construct a branch instruction
"branch <expr> <label> <label>".

program: GOTO TRIPLE_DOT 
##
## Ends in an error in state: 93.
##
## instruction -> GOTO . label [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## GOTO 
##

Parsing an instruction, we parsed "goto" so far; a label, for example
"foo", is now expected to construct a goto instruction
"goto <label>".

program: IDENTIFIER LEFTARROW TRIPLE_DOT 
##
## Ends in an error in state: 113.
##
## instruction -> variable LEFTARROW . expression [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## variable LEFTARROW 
##

Parsing an instruction, we parsed "<var> <-" so far; an expression,
for example "(x + 1)", is now expected to construct an assignment
"<var> <- <expression>".

program: IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 92.
##
## label -> IDENTIFIER . [ COLON ]
## variable -> IDENTIFIER . [ LEFTARROW LBRACKET ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER 
##

Parsing an instruction, we parsed an identifier so far (variable or label). 
- if this is a label declaration, we expect a semicolon: "<label>:"
- if this is an assignment, we expect a left arrow: "<var> <- <expression>"

program: OSR NIL IDENTIFIER IDENTIFIER IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 79.
##
## instruction -> OSR expression label label label . LBRACKET loption(separated_nonempty_list(COMMA,osr_def)) RBRACKET [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## OSR expression label label label 
##

Parsing the specification of the new environment of an osr instruction
failed. After "osr <function> <version> <label>" we expect an
environment mapping as a square bracket enclosed, comma-separated list
of terms of the form "const x = e" (where "e" is an expression),
"mut x = e", "mut x = &y" or just "mut x". For example,
"osr Main optimized l2 [const x = e, mut y = &y, mut z]".

program: OSR NIL IDENTIFIER IDENTIFIER IDENTIFIER LBRACKET TRIPLE_DOT 
##
## Ends in an error in state: 80.
##
## instruction -> OSR expression label label label LBRACKET . loption(separated_nonempty_list(COMMA,osr_def)) RBRACKET [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## OSR expression label label label LBRACKET 
##

Parsing the specification of the new environment of an osr instruction
failed. After "osr <function> <version> <label> [" we expect an
environment mapping as a comma-separated list of terms of the form
"const x = e" (where "e" is an expression), "mut x = e", "mut x = &y"
or just "mut x". For example,
"osr Main optimized l2 [const x = e, mut y = &y, mut z]".

program: OSR NIL IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 77.
##
## instruction -> OSR expression label . label label LBRACKET loption(separated_nonempty_list(COMMA,osr_def)) RBRACKET [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## OSR expression label 
##

Parsing an osr instruction, we parsed "osr <expr> <version>", and are
now expecting a label. The complete instruction syntax is "osr <expr>
<version> <label> [<new_env>]", where "<new_env>" is a specification
of the environment mapping. It's a comma-separated list of terms of
the form "const x = e" (where "e" is an expression), "mut x = e",
"mut x = &y" or just "mut x". For example,
"osr Main optimized l2 [const x = e, mut y = &y, mut z]".

program: OSR NIL TRIPLE_DOT 
##
## Ends in an error in state: 75.
##
## instruction -> OSR expression . label label label LBRACKET loption(separated_nonempty_list(COMMA,osr_def)) RBRACKET [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## OSR expression 
##

Parsing an osr instruction, we parsed "osr <expr>", and are now
expecting a version label, for example "foo". The complete instruction
syntax is "osr <expr> <version> <label> [<new_env>]", where
"<new_env>" is a specification of the environment mapping. It's
a comma-separated list of terms of the form "const x = e" (where "e"
is an expression), "mut x = e", "mut x = &y" or just "mut x". For
example, "osr Main optimized l2 [const x = e, mut y = &y, mut z]".

program: OSR TRIPLE_DOT 
##
## Ends in an error in state: 74.
##
## instruction -> OSR . expression label label label LBRACKET loption(separated_nonempty_list(COMMA,osr_def)) RBRACKET [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## OSR 
##

Parsing an osr instruction, we parsed "osr", and are now expecting an
expression, for example "(x + 1)". The complete instruction syntax is
"osr <expr> <version> <label> [<new_env>]", where "<new_env>" is
a specification of the new environment. It's a comma-separated list of
terms of the form "const x = e" (where "e" is an expression),
"mut x = e", "mut x = &y" or just "mut x". For example,
"osr Main optimized l2 [const x = e, mut y = &y, mut z]".

program: LBRACE TRIPLE_DOT RBRACE BOOL 
##
## Ends in an error in state: 12.
##
## scope_annotation -> LBRACE scope RBRACE . optional_newlines [ VAR RETURN READ PRINT OSR IDENTIFIER GOTO COMMENT CALL BRANCH ]
##
## The known suffix of the stack is as follows:
## LBRACE scope RBRACE 
##

We parsed a scope annotation, and we now expect an instruction
followed by a line break.

program: LBRACE TRIPLE_DOT TRIPLE_DOT 
##
## Ends in an error in state: 11.
##
## scope_annotation -> LBRACE scope . RBRACE optional_newlines [ VAR RETURN READ PRINT OSR IDENTIFIER GOTO COMMENT CALL BRANCH ]
##
## The known suffix of the stack is as follows:
## LBRACE scope 
##

In a scope annotation, "..." should be the last item. "{ x, ... }" or
"{ ... }" are valid, but "{ ..., x }" is not.

program: VAR IDENTIFIER EQUAL TRIPLE_DOT 
##
## Ends in an error in state: 31.
##
## instruction -> VAR variable EQUAL . expression [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## VAR variable EQUAL 
##

Parsing a varable declaration instruction, we parsed "var <var> =" so
far; an expression is now expected, for example "(x + 1)", to
construct a constant varable instruction "var <var> = <expr>".

program: VAR IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 30.
##
## instruction -> VAR variable . EQUAL expression [ NEWLINE ]
## instruction -> VAR variable . [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## VAR variable 
##

Parsing a varable declaration instruction, we parsed "var <var>" so
far; an equal sign "=" is now expected to construct a constant varable
instruction "var <var> = <expr>".

program: VAR TRIPLE_DOT 
##
## Ends in an error in state: 29.
##
## instruction -> VAR . variable EQUAL expression [ NEWLINE ]
## instruction -> VAR . variable [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## VAR 
##

Parsing an instruction, we parsed "var" so far; a variable, for
example "x", is now expected to construct a varable variable
declaration
"var <var> = <expr>".

program: PRINT LPAREN IDENTIFIER PLUS IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 44.
##
## expression -> LPAREN simple_expression infixop simple_expression . RPAREN [ RPAREN RBRACKET NEWLINE LPAREN IDENTIFIER COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN simple_expression infixop simple_expression 
##

Parsing an expression, we parsed "( <arg> <op> <arg>" so far;
a closing parenthesis ")" is now expected.

program: PRINT LPAREN IDENTIFIER PLUS TRIPLE_DOT 
##
## Ends in an error in state: 43.
##
## expression -> LPAREN simple_expression infixop . simple_expression RPAREN [ RPAREN RBRACKET NEWLINE LPAREN IDENTIFIER COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN simple_expression infixop 
##

Parsing an expression, we parsed "( <arg> <op>" so far; an argument
(variable or literal value) is now expected to construct an expression
"( <arg> <op> <arg> )".

program: PRINT LPAREN IDENTIFIER TRIPLE_DOT 
##
## Ends in an error in state: 39.
##
## expression -> LPAREN simple_expression . infixop simple_expression RPAREN [ RPAREN RBRACKET NEWLINE LPAREN IDENTIFIER COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN simple_expression 
##

Parsing an expression, we parsed "( <arg>" so far; an operator such as
"+", "==" or "!=" is now expected to construct an expression
"( <var> <op> <var> )".

program: PRINT LPAREN TRIPLE_DOT 
##
## Ends in an error in state: 35.
##
## expression -> LPAREN . simple_expression infixop simple_expression RPAREN [ RPAREN RBRACKET NEWLINE LPAREN IDENTIFIER COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing an expression, we parsed "(" so far; an argument (variable or
literal value) is now expected to construct an expression
"( <arg> <op> <arg> )".

program: PRINT TRIPLE_DOT 
##
## Ends in an error in state: 72.
##
## instruction -> PRINT . expression [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## PRINT 
##

Parsing an instruction, we parsed "print" so far;
an expression, for example "(x + 1)", is now expected
to construct a print instruction
"print <expr>".

program: READ TRIPLE_DOT 
##
## Ends in an error in state: 70.
##
## instruction -> READ . variable [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## READ 
##

Parsing an instruction, we parsed "read" so far;
a variable, for example "x", is now expected
to construct a read assignment
"read <var>".
Note that the variable needs to have been declared as mutable first.

program: TRIPLE_DOT 
##
## Ends in an error in state: 0.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
## 
##

We parsed a correct program so far; extra instructions, or the end of
the file, are now expected.

